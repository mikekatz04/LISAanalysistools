<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>lisatools.diagnostic &mdash; lisaanalysistools 1.0.9 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=0abd802e"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            lisaanalysistools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Documentation:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../user/sensitivity.html">Sensitivity Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/detector.html">Detector Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/stochastic.html">Stochastic Signals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/datacontainer.html">Data / Residual / Signal Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/datacontainer.html#analysis-container">Analysis Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/diagnostic.html">Diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../user/sources.html">GW Source Tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorial:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/lisatools_tutorial.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/lisatools_tutorial.html#LISA-Sensitivity">LISA Sensitivity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/lisatools_tutorial.html#Orbits">Orbits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/lisatools_tutorial.html#Defining-a-LISAModel">Defining a <code class="docutils literal notranslate"><span class="pre">LISAModel</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/lisatools_tutorial.html#Diagnostics">Diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/lisatools_tutorial.html#Data-/-Residual-/-Signal-Container">Data / Residual / Signal Container</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/lisatools_tutorial.html#Analysis-Container">Analysis Container</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">lisaanalysistools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">lisatools.diagnostic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for lisatools.diagnostic</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">eryn.utils</span> <span class="kn">import</span> <span class="n">TransformContainer</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>

<span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">cp</span>

    <span class="k">pass</span>

<span class="kn">from</span> <span class="nn">.sensitivity</span> <span class="kn">import</span> <span class="n">get_sensitivity</span><span class="p">,</span> <span class="n">SensitivityMatrix</span>
<span class="kn">from</span> <span class="nn">.datacontainer</span> <span class="kn">import</span> <span class="n">DataResidualArray</span>
<span class="kn">from</span> <span class="nn">.utils.utility</span> <span class="kn">import</span> <span class="n">get_array_module</span>


<div class="viewcode-block" id="inner_product">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.inner_product">[docs]</a>
<span class="k">def</span> <span class="nf">inner_product</span><span class="p">(</span>
    <span class="n">sig1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">DataResidualArray</span><span class="p">,</span>
    <span class="n">sig2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">DataResidualArray</span><span class="p">,</span>
    <span class="n">dt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">f_arr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">psd</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">SensitivityMatrix</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;LISASens&quot;</span><span class="p">,</span>
    <span class="n">psd_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">psd_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="nb">complex</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the inner product between two signals weighted by a psd.</span>

<span class="sd">    The inner product between time series :math:`a(t)` and :math:`b(t)` is</span>

<span class="sd">    .. math::</span>

<span class="sd">        \langle a | b \\rangle = 2\int_{f_\\text{min}}^{f_\\text{max}} \\frac{\\tilde{a}(f)^*\\tilde{b}(f) + \\tilde{a}(f)\\tilde{b}(f)^*}{S_n(f)} df\ \ ,</span>

<span class="sd">    where :math:`\\tilde{a}(f)` is the Fourier transform of :math:`a(t)` and :math:`S_n(f)` is the one-sided Power Spectral Density of the noise.</span>

<span class="sd">    The inner product can be left complex using the ``complex`` kwarg.</span>

<span class="sd">    **GPU Capability**: Pass CuPy arrays rather than NumPy arrays.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig1: First signal to use for the inner product.</span>
<span class="sd">            Can be time-domain or frequency-domain.</span>
<span class="sd">            Must be 1D ``np.ndarray``, list of 1D ``np.ndarray``s, or 2D ``np.ndarray``</span>
<span class="sd">            across channels with shape ``(nchannels, data length)``.</span>
<span class="sd">        sig2: Second signal to use for the inner product.</span>
<span class="sd">            Can be time-domain or frequency-domain.</span>
<span class="sd">            Must be 1D ``np.ndarray``, list of 1D ``np.ndarray``s, or 2D ``np.ndarray``</span>
<span class="sd">            across channels with shape ``(nchannels, data length)``.</span>
<span class="sd">        dt: Time step in seconds. If provided, assumes time-domain signals.</span>
<span class="sd">        df: Constant frequency spacing. This will assume a frequency domain signal with constant frequency spacing.</span>
<span class="sd">        f_arr: Array of specific frequencies at which the signal is given.</span>
<span class="sd">        psd: Indicator of what psd to use. If a ``str``, this will be passed as the ``sens_fn`` kwarg to :func:`get_sensitivity`.</span>
<span class="sd">            If ``None``, it will be an array of ones. Or, you can pass a 1D ``np.ndarray`` of psd values that must be the same length</span>
<span class="sd">            as the frequency domain signals.</span>
<span class="sd">        psd_args: Arguments to pass to the psd function if ``type(psd) == str``.</span>
<span class="sd">        psd_kwargs: Keyword arguments to pass to the psd function if ``type(psd) == str``.</span>
<span class="sd">        normalize: Normalize the inner product. If ``True``, it will normalize the square root of the product of individual signal inner products.</span>
<span class="sd">            You can also pass ``&quot;sig1&quot;`` or ``&quot;sig2&quot;`` to normalize with respect to one signal.</span>
<span class="sd">        complex: If ``True``, return the complex value of the inner product rather than just its real-valued part.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Inner product value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initial input checks and setup</span>
    <span class="n">sig1</span> <span class="o">=</span> <span class="n">DataResidualArray</span><span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">f_arr</span><span class="o">=</span><span class="n">f_arr</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>
    <span class="n">sig2</span> <span class="o">=</span> <span class="n">DataResidualArray</span><span class="p">(</span><span class="n">sig2</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">f_arr</span><span class="o">=</span><span class="n">f_arr</span><span class="p">,</span> <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sig1</span><span class="o">.</span><span class="n">nchannels</span> <span class="o">!=</span> <span class="n">sig2</span><span class="o">.</span><span class="n">nchannels</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Signal 1 has </span><span class="si">{</span><span class="n">sig1</span><span class="o">.</span><span class="n">nchannels</span><span class="si">}</span><span class="s2"> channels. Signal 2 has </span><span class="si">{</span><span class="n">sig2</span><span class="o">.</span><span class="n">nchannels</span><span class="si">}</span><span class="s2"> channels. Must be the same.&quot;</span>
        <span class="p">)</span>

    <span class="n">xp</span> <span class="o">=</span> <span class="n">get_array_module</span><span class="p">(</span><span class="n">sig1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># checks</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sig1</span><span class="o">.</span><span class="n">nchannels</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">sig2</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Array in sig1, index 0 sets array module. Not all arrays match that module type (Numpy or Cupy)&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">sig1</span><span class="o">.</span><span class="n">data_length</span> <span class="o">!=</span> <span class="n">sig2</span><span class="o">.</span><span class="n">data_length</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The two signals are two different lengths. Must be the same length.&quot;</span>
        <span class="p">)</span>

    <span class="n">freqs</span> <span class="o">=</span> <span class="n">sig1</span><span class="o">.</span><span class="n">f_arr</span>

    <span class="c1"># get psd weighting</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">SensitivityMatrix</span><span class="p">):</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">SensitivityMatrix</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="p">[</span><span class="n">psd</span><span class="p">],</span> <span class="o">*</span><span class="n">psd_args</span><span class="p">,</span> <span class="o">**</span><span class="n">psd_kwargs</span><span class="p">)</span>

    <span class="n">operational_sets</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">psd</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sig1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sig2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="k">else</span> <span class="mf">2.0</span>
                <span class="n">operational_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="nb">dict</span><span class="p">(</span><span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">,</span> <span class="n">sig1_ind</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">sig2_ind</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">psd_ind</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="p">)</span>

    <span class="k">elif</span> <span class="n">psd</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sig1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">sig2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">operational_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sig1_ind</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">sig2_ind</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">psd_ind</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>

    <span class="k">elif</span> <span class="n">psd</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sig1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">operational_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sig1_ind</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">sig2_ind</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">psd_ind</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;# TODO&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">complex</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">real</span>

    <span class="c1"># initialize</span>
    <span class="n">out</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">freqs</span>

    <span class="c1"># account for hp and hx if included in time domain signal</span>
    <span class="k">for</span> <span class="n">op_set</span> <span class="ow">in</span> <span class="n">operational_sets</span><span class="p">:</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="n">op_set</span><span class="p">[</span><span class="s2">&quot;factor&quot;</span><span class="p">]</span>

        <span class="n">temp1</span> <span class="o">=</span> <span class="n">sig1</span><span class="p">[</span><span class="n">op_set</span><span class="p">[</span><span class="s2">&quot;sig1_ind&quot;</span><span class="p">]]</span>
        <span class="n">temp2</span> <span class="o">=</span> <span class="n">sig2</span><span class="p">[</span><span class="n">op_set</span><span class="p">[</span><span class="s2">&quot;sig2_ind&quot;</span><span class="p">]]</span>
        <span class="n">psd_tmp</span> <span class="o">=</span> <span class="n">psd</span><span class="p">[</span><span class="n">op_set</span><span class="p">[</span><span class="s2">&quot;psd_ind&quot;</span><span class="p">]]</span>

        <span class="n">ind_start</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">psd_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">func</span><span class="p">(</span><span class="n">temp1</span><span class="p">[</span><span class="n">ind_start</span><span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="n">temp2</span><span class="p">[</span><span class="n">ind_start</span><span class="p">:])</span> <span class="o">/</span> <span class="n">psd_tmp</span><span class="p">[</span><span class="n">ind_start</span><span class="p">:]</span>
        <span class="p">)</span>  <span class="c1"># assumes right summation rule</span>
        <span class="c1"># df is sunk into trapz</span>
        <span class="n">tmp_out</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">xp</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">ind_start</span><span class="p">:])</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">tmp_out</span>

    <span class="c1"># normalize the inner produce</span>
    <span class="n">normalization_value</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">if</span> <span class="n">normalize</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">norm1</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span>
            <span class="n">sig1</span><span class="p">,</span>
            <span class="n">sig1</span><span class="p">,</span>
            <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">norm2</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span>
            <span class="n">sig2</span><span class="p">,</span>
            <span class="n">sig2</span><span class="p">,</span>
            <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">normalization_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm1</span> <span class="o">*</span> <span class="n">norm2</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">normalize</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">normalize</span> <span class="o">==</span> <span class="s2">&quot;sig1&quot;</span><span class="p">:</span>
            <span class="n">sig_to_normalize</span> <span class="o">=</span> <span class="n">sig1</span>

        <span class="k">elif</span> <span class="n">normalize</span> <span class="o">==</span> <span class="s2">&quot;sig2&quot;</span><span class="p">:</span>
            <span class="n">sig_to_normalize</span> <span class="o">=</span> <span class="n">sig2</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If normalizing with respect to sig1 or sig2, normalize kwarg must either be &#39;sig1&#39; or &#39;sig2&#39;.&quot;</span>
            <span class="p">)</span>

        <span class="n">normalization_value</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span>
            <span class="n">sig_to_normalize</span><span class="p">,</span>
            <span class="n">sig_to_normalize</span><span class="p">,</span>
            <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">normalize</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normalize must be True, False, &#39;sig1&#39;, or &#39;sig2&#39;.&quot;</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">/=</span> <span class="n">normalization_value</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="residual_source_likelihood_term">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.residual_source_likelihood_term">[docs]</a>
<span class="k">def</span> <span class="nf">residual_source_likelihood_term</span><span class="p">(</span>
    <span class="n">data_res_arr</span><span class="p">:</span> <span class="n">DataResidualArray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the source term in the Likelihood for a data residual (d - h).</span>

<span class="sd">    The source term in the likelihood is given by,</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\log{\\mathcal{L}}_\\text{src} = -\\frac{1}{2}\\langle \\vec{d} - \\vec{h} | \\vec{d} - \\vec{h}\\rangle.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_res_arr: Data residual.</span>
<span class="sd">        **kwargs: Keyword arguments to pass to :func:`inner_product`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Source term Likelihood value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;normalize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">ip_val</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span><span class="n">data_res_arr</span><span class="p">,</span> <span class="n">data_res_arr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">ip_val</span></div>



<div class="viewcode-block" id="noise_likelihood_term">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.noise_likelihood_term">[docs]</a>
<span class="k">def</span> <span class="nf">noise_likelihood_term</span><span class="p">(</span><span class="n">psd</span><span class="p">:</span> <span class="n">SensitivityMatrix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the noise term in the Likelihood.</span>

<span class="sd">    The noise term in the likelihood is given by,</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\log{\\mathcal{L}}_n = -\\sum \\log{\\vec{S}_n}.</span>

<span class="sd">    Args:</span>
<span class="sd">        psd: Sensitivity information.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Noise term Likelihood value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">psd</span><span class="p">[:])</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">psd</span><span class="p">[:])</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fix</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">psd</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="n">nl_val</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">psd</span><span class="p">[</span><span class="o">~</span><span class="n">fix</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">nl_val</span></div>



<div class="viewcode-block" id="residual_full_source_and_noise_likelihood">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.residual_full_source_and_noise_likelihood">[docs]</a>
<span class="k">def</span> <span class="nf">residual_full_source_and_noise_likelihood</span><span class="p">(</span>
    <span class="n">data_res_arr</span><span class="p">:</span> <span class="n">DataResidualArray</span><span class="p">,</span>
    <span class="n">psd</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">SensitivityMatrix</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the full Likelihood including noise and source terms.</span>

<span class="sd">    The noise term is calculated with :func:`noise_likelihood_term`.</span>

<span class="sd">    The source term is calcualted with :func:`residual_source_likelihood_term`.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_res_arr: Data residual.</span>
<span class="sd">        psd: Sensitivity information.</span>
<span class="sd">        **kwargs: Keyword arguments to pass to :func:`inner_product`.</span>

<span class="sd">    Returns:</span>
<span class="sd">       Full Likelihood value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">SensitivityMatrix</span><span class="p">):</span>
        <span class="c1"># TODO: maybe adjust so it can take a list just like Sensitivity matrix</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">SensitivityMatrix</span><span class="p">(</span><span class="n">data_res_arr</span><span class="o">.</span><span class="n">f_arr</span><span class="p">,</span> <span class="p">[</span><span class="n">psd</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># remove key</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="s2">&quot;psd&quot;</span><span class="p">,</span> <span class="s2">&quot;psd_args&quot;</span><span class="p">,</span> <span class="s2">&quot;psd_kwargs&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="n">rslt</span> <span class="o">=</span> <span class="n">residual_source_likelihood_term</span><span class="p">(</span><span class="n">data_res_arr</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">nlt</span> <span class="o">=</span> <span class="n">noise_likelihood_term</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nlt</span> <span class="o">+</span> <span class="n">rslt</span></div>



<div class="viewcode-block" id="data_signal_source_likelihood_term">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.data_signal_source_likelihood_term">[docs]</a>
<span class="k">def</span> <span class="nf">data_signal_source_likelihood_term</span><span class="p">(</span>
    <span class="n">data_arr</span><span class="p">:</span> <span class="n">DataResidualArray</span><span class="p">,</span> <span class="n">sig_arr</span><span class="p">:</span> <span class="n">DataResidualArray</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the source term in the Likelihood for separate signal and data.</span>

<span class="sd">    The source term in the likelihood is given by,</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\log{\\mathcal{L}}_\\text{src} = -\\frac{1}{2}\\left(\\langle \\vec{d} | \\vec{d}\\rangle + \\langle \\vec{h} | \\vec{h}\\rangle - 2\\langle \\vec{d} | \\vec{h}\\rangle \\right)\ \ .</span>

<span class="sd">    Args:</span>
<span class="sd">        data_arr: Data.</span>
<span class="sd">        sig_arr: Signal.</span>
<span class="sd">        **kwargs: Keyword arguments to pass to :func:`inner_product`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Source term Likelihood value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;normalize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">d_h</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">sig_arr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">h_h</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span><span class="n">sig_arr</span><span class="p">,</span> <span class="n">sig_arr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">d_d</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">data_arr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">d_d</span> <span class="o">+</span> <span class="n">h_h</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">d_h</span><span class="p">)</span></div>



<div class="viewcode-block" id="data_signal_full_source_and_noise_likelihood">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.data_signal_full_source_and_noise_likelihood">[docs]</a>
<span class="k">def</span> <span class="nf">data_signal_full_source_and_noise_likelihood</span><span class="p">(</span>
    <span class="n">data_arr</span><span class="p">:</span> <span class="n">DataResidualArray</span><span class="p">,</span>
    <span class="n">sig_arr</span><span class="p">:</span> <span class="n">DataResidualArray</span><span class="p">,</span>
    <span class="n">psd</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">SensitivityMatrix</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">complex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the full Likelihood including noise and source terms.</span>

<span class="sd">    Here, the signal is treated separate from the data.</span>

<span class="sd">    The noise term is calculated with :func:`noise_likelihood_term`.</span>

<span class="sd">    The source term is calcualted with :func:`data_signal_source_likelihood_term`.</span>

<span class="sd">    Args:</span>
<span class="sd">        data_arr: Data.</span>
<span class="sd">        sig_arr: Signal.</span>
<span class="sd">        psd: Sensitivity information.</span>
<span class="sd">        **kwargs: Keyword arguments to pass to :func:`inner_product`.</span>

<span class="sd">    Returns:</span>
<span class="sd">       Full Likelihood value.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psd</span><span class="p">,</span> <span class="n">SensitivityMatrix</span><span class="p">):</span>
        <span class="c1"># TODO: maybe adjust so it can take a list just like Sensitivity matrix</span>
        <span class="n">psd</span> <span class="o">=</span> <span class="n">SensitivityMatrix</span><span class="p">(</span><span class="n">data_arr</span><span class="o">.</span><span class="n">f_arr</span><span class="p">,</span> <span class="p">[</span><span class="n">psd</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># remove key</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="s2">&quot;psd&quot;</span><span class="p">,</span> <span class="s2">&quot;psd_args&quot;</span><span class="p">,</span> <span class="s2">&quot;psd_kwargs&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="n">rslt</span> <span class="o">=</span> <span class="n">data_signal_source_likelihood_term</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">sig_arr</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="n">psd</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">nlt</span> <span class="o">=</span> <span class="n">noise_likelihood_term</span><span class="p">(</span><span class="n">psd</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nlt</span> <span class="o">+</span> <span class="n">rslt</span></div>



<div class="viewcode-block" id="snr">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.snr">[docs]</a>
<span class="k">def</span> <span class="nf">snr</span><span class="p">(</span>
    <span class="n">sig1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">DataResidualArray</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">DataResidualArray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the snr between two signals weighted by a psd.</span>

<span class="sd">    The signal-to-noise ratio of a signal is :math:`\\sqrt{\\langle a|a\\rangle}`.</span>

<span class="sd">    This will be the optimal SNR if ``data==None``. If a data array is given, it will be the observed</span>
<span class="sd">    SNR: :math:`\\langle d|a\\rangle/\\sqrt{\\langle a|a\\rangle}`.</span>

<span class="sd">    **GPU Capability**: Pass CuPy arrays rather than NumPy arrays.</span>

<span class="sd">    Args:</span>
<span class="sd">        sig1: Signal to use as the templatefor the SNR.</span>
<span class="sd">            Can be time-domain or frequency-domain.</span>
<span class="sd">            Must be 1D ``np.ndarray``, list of 1D ``np.ndarray``s, or 2D ``np.ndarray``</span>
<span class="sd">            across channels with shape ``(nchannels, data length)``.</span>
<span class="sd">        *args: Arguments to pass to :func:`inner_product`.</span>
<span class="sd">        data: Data becomes the ``sig2`` argument to :func:`inner_product`.</span>
<span class="sd">        **kwargs: Keyword arguments to pass to :func:`inner_product`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Optimal or detected SNR value (depending on ``data`` kwarg).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get optimal SNR</span>
    <span class="n">opt_snr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">inner_product</span><span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">sig1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">opt_snr</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if inputed data, calculate detected SNR</span>
        <span class="n">det_snr</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">/</span> <span class="n">opt_snr</span>
        <span class="k">return</span> <span class="n">det_snr</span></div>



<div class="viewcode-block" id="h_var_p_eps">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.h_var_p_eps">[docs]</a>
<span class="k">def</span> <span class="nf">h_var_p_eps</span><span class="p">(</span>
    <span class="n">step</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">waveform_model</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">parameter_transforms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TransformContainer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">waveform_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">waveform_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>  <span class="c1"># TODO: check this</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the waveform with a perturbation step of the variable V[i]</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform_model: Callable function to the waveform generator with signature ``(*params, **waveform_kwargs)``.</span>
<span class="sd">        params: Source parameters that are over derivatives (not in fill dict of parameter transforms)</span>
<span class="sd">        step: Absolute step size for variable of interest.</span>
<span class="sd">        index: Index to parameter of interest.</span>
<span class="sd">        parameter_transforms: `TransformContainer &lt;https://mikekatz04.github.io/Eryn/html/user/utils.html#eryn.utils.TransformContainer&gt;`_ object to transform from the derivative parameter basis</span>
<span class="sd">            to the waveform parameter basis. This class can also fill in fixed parameters where the derivatives are not being taken.</span>
<span class="sd">        waveform_args: args (beyond parameters) for the waveform generator.</span>
<span class="sd">        waveform_kwargs: kwargs for the waveform generation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Perturbation to the waveform in the given parameter. Will always be 2D array with shape ``(num channels, data length)``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params_p_eps</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">params_p_eps</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">step</span>

    <span class="k">if</span> <span class="n">parameter_transforms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># transform</span>
        <span class="n">params_p_eps</span> <span class="o">=</span> <span class="n">parameter_transforms</span><span class="o">.</span><span class="n">transform_base_parameters</span><span class="p">(</span>
            <span class="n">params_p_eps</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">args_in</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params_p_eps</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">waveform_args</span><span class="p">)</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="n">waveform_model</span><span class="p">(</span><span class="o">*</span><span class="n">args_in</span><span class="p">,</span> <span class="o">**</span><span class="n">waveform_kwargs</span><span class="p">)</span>

    <span class="c1"># adjust output based on waveform model output</span>
    <span class="c1"># needs to be 2D array</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">dh</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">get_array_module</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dh</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">get_array_module</span><span class="p">(</span><span class="n">dh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">xp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dh</span></div>



<div class="viewcode-block" id="dh_dlambda">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.dh_dlambda">[docs]</a>
<span class="k">def</span> <span class="nf">dh_dlambda</span><span class="p">(</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
    <span class="n">more_accurate</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Derivative of the waveform</span>

<span class="sd">    Calculate the derivative of the waveform with precision of order (step^4)</span>
<span class="sd">    with respect to the variable V in the i direction.</span>

<span class="sd">    Args:</span>
<span class="sd">        eps: Absolute **derivative** step size for variable of interest.</span>
<span class="sd">        *args: Arguments passed to :func:`h_var_p_eps`.</span>
<span class="sd">        more_accurate: If ``True``, run a more accurate derivate requiring 2x more waveform generations.</span>
<span class="sd">        **kwargs: Keyword arguments passed to :func:`h_var_p_eps`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Numerical derivative of the waveform with respect to a varibale of interest. Will be 2D array</span>
<span class="sd">        with shape ``(num channels, data length)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">more_accurate</span><span class="p">:</span>
        <span class="c1"># Derivative of the Waveform</span>
        <span class="c1"># up</span>
        <span class="n">h_I_up_2eps</span> <span class="o">=</span> <span class="n">h_var_p_eps</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">h_I_up_eps</span> <span class="o">=</span> <span class="n">h_var_p_eps</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># down</span>
        <span class="n">h_I_down_2eps</span> <span class="o">=</span> <span class="n">h_var_p_eps</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">h_I_down_eps</span> <span class="o">=</span> <span class="n">h_var_p_eps</span><span class="p">(</span><span class="o">-</span><span class="n">eps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># make sure they are all the same length</span>
        <span class="n">ind_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">h_I_up_2eps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">h_I_up_eps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">h_I_down_2eps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">h_I_down_eps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># error scales as eps^4</span>
        <span class="n">dh_I</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="n">h_I_up_2eps</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ind_max</span><span class="p">]</span>
            <span class="o">+</span> <span class="n">h_I_down_2eps</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ind_max</span><span class="p">]</span>
            <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">(</span><span class="n">h_I_up_eps</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ind_max</span><span class="p">]</span> <span class="o">-</span> <span class="n">h_I_down_eps</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ind_max</span><span class="p">])</span>
        <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">12</span> <span class="o">*</span> <span class="n">eps</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Derivative of the Waveform</span>
        <span class="c1"># up</span>
        <span class="n">h_I_up_eps</span> <span class="o">=</span> <span class="n">h_var_p_eps</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># down</span>
        <span class="n">h_I_down_eps</span> <span class="o">=</span> <span class="n">h_var_p_eps</span><span class="p">(</span><span class="o">-</span><span class="n">eps</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">ind_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">h_I_up_eps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">h_I_down_eps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

        <span class="c1"># TODO: check what error scales as.</span>
        <span class="n">dh_I</span> <span class="o">=</span> <span class="p">(</span><span class="n">h_I_up_eps</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ind_max</span><span class="p">]</span> <span class="o">-</span> <span class="n">h_I_down_eps</span><span class="p">[:,</span> <span class="p">:</span><span class="n">ind_max</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">eps</span><span class="p">)</span>
        <span class="c1"># Time thta it takes for one variable: approx 5 minutes</span>

    <span class="k">return</span> <span class="n">dh_I</span></div>



<div class="viewcode-block" id="info_matrix">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.info_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">info_matrix</span><span class="p">(</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">waveform_model</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">deriv_inds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">inner_product_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">return_derivs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate Information Matrix.</span>

<span class="sd">    This calculates the information matrix for a given waveform model at a given set of parameters.</span>
<span class="sd">    The inverse of the information matrix gives the covariance matrix.</span>

<span class="sd">    This is also referred to as the Fisher information matrix, but @MichaelKatz has chosen to leave out the name because of `this &lt;https://www.newstatesman.com/long-reads/2020/07/ra-fisher-and-science-hatred&gt;`_.</span>

<span class="sd">    The info matrix is given by:</span>

<span class="sd">    .. math::</span>

<span class="sd">        M_{ij} = \\langle h_i | h_j \\rangle \\text{ with } h_i = \\frac{\\partial h}{\\partial \\lambda_i}.</span>

<span class="sd">    Args:</span>
<span class="sd">        eps: Absolute **derivative** step size for variable of interest. Can be provided as a ``float`` value that applies</span>
<span class="sd">            to all variables or an array, one for each parameter being evaluated in the information matrix.</span>
<span class="sd">        waveform_model: Callable function to the waveform generator with signature ``(*params, **waveform_kwargs)``.</span>
<span class="sd">        params: Source parameters.</span>
<span class="sd">        deriv_inds: Subset of parameters of interest for which to calculate the information matrix, by index.</span>
<span class="sd">            If ``None``, it will be ``np.arange(len(params))``.</span>
<span class="sd">        inner_product_kwargs: Keyword arguments for the inner product function.</span>
<span class="sd">        return_derivs: If ``True``, also returns computed numerical derivatives.</span>
<span class="sd">        **kwargs: Keyword arguments passed to :func:`dh_dlambda`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        If ``not return_derivs``, this will be the information matrix as a numpy array. If ``return_derivs is True``,</span>
<span class="sd">        it will be a tuple with the first entry as the information matrix and the second entry as the partial derivatives.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># setup initial information</span>
    <span class="n">num_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">deriv_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">deriv_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_params</span><span class="p">)</span>

    <span class="n">num_info_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">deriv_inds</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">eps</span><span class="p">)</span>

    <span class="c1"># collect derivatives over the variables of interest</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">eps_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">deriv_inds</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
        <span class="c1"># derivative up</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">dh_dlambda</span><span class="p">(</span><span class="n">eps_i</span><span class="p">,</span> <span class="n">waveform_model</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">dh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

    <span class="c1"># calculate the components of the symmetric matrix</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_info_params</span><span class="p">,</span> <span class="n">num_info_params</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_info_params</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">num_info_params</span><span class="p">):</span>
            <span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">inner_product</span><span class="p">(</span>
                <span class="p">[</span><span class="n">dh</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dh</span><span class="p">[</span><span class="n">i</span><span class="p">]))],</span>
                <span class="p">[</span><span class="n">dh</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dh</span><span class="p">[</span><span class="n">i</span><span class="p">]))],</span>
                <span class="o">**</span><span class="n">inner_product_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">info</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_derivs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">info</span><span class="p">,</span> <span class="n">dh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">info</span></div>



<div class="viewcode-block" id="covariance">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.covariance">[docs]</a>
<span class="k">def</span> <span class="nf">covariance</span><span class="p">(</span>
    <span class="o">*</span><span class="n">info_mat_args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
    <span class="n">info_mat</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">diagonalize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_info_mat</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">precision</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">info_mat_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate covariance matrix for a set of EMRI parameters, computing the information matrix if not supplied.</span>

<span class="sd">    Args:</span>
<span class="sd">        *info_mat_args: Set of arguments to pass to :func:`info_matrix`. Not required if ``info_mat`` is not ``None``.</span>
<span class="sd">        info_mat: Pre-computed information matrix. If supplied, this matrix will be inverted.</span>
<span class="sd">        diagonalize: If ``True``, diagonalizes the covariance matrix.</span>
<span class="sd">        return_info_mat: If ``True``, also returns the computed information matrix.</span>
<span class="sd">        precision: If ``True``, uses 500-dps precision to compute the information matrix inverse (requires `mpmath &lt;https://mpmath.org&gt;`_). This is typically a good idea as the information matrix can be highly ill-conditioned.</span>
<span class="sd">        **info_mat_kwargs: Keyword arguments to pass to :func:`info_matrix`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Covariance matrix. If ``return_info_mat is True``. A list will be returned with the covariance as the first</span>
<span class="sd">        entry and the information matrix as the second entry. If ``return_derivs is True`` (keyword argument to :func:`info_matrix`),</span>
<span class="sd">        then another entry will be added to the list for the derivatives.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">info_mat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">info_mat</span> <span class="o">=</span> <span class="n">info_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">info_mat_args</span><span class="p">,</span> <span class="o">**</span><span class="n">info_mat_kwargs</span><span class="p">)</span>

    <span class="c1"># parse output properly</span>
    <span class="k">if</span> <span class="s2">&quot;return_derivs&quot;</span> <span class="ow">in</span> <span class="n">info_mat_kwargs</span> <span class="ow">and</span> <span class="n">info_mat_kwargs</span><span class="p">[</span><span class="s2">&quot;return_derivs&quot;</span><span class="p">]:</span>
        <span class="n">return_derivs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">info_mat</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">info_mat</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_derivs</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># attempt to import and setup mpmath if precision required</span>
    <span class="k">if</span> <span class="n">precision</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">mpmath</span> <span class="k">as</span> <span class="nn">mp</span>

            <span class="n">mp</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mpmath module not installed. Defaulting to low precision...&quot;</span><span class="p">)</span>
            <span class="n">precision</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">precision</span><span class="p">:</span>
        <span class="n">hp_info_mat</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">info_mat</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">svd_r</span><span class="p">(</span><span class="n">hp_info_mat</span><span class="p">)</span>  <span class="c1"># singular value decomposition</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">val</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">S</span><span class="p">])</span>  <span class="c1"># get S**-1</span>
        <span class="n">temp2</span> <span class="o">=</span> <span class="n">V</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># construct pseudo-inverse</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">temp2</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">info_mat</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">diagonalize</span><span class="p">:</span>
        <span class="c1"># get eigeninformation</span>
        <span class="n">eig_vals</span><span class="p">,</span> <span class="n">eig_vecs</span> <span class="o">=</span> <span class="n">get_eigeninfo</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">high_precision</span><span class="o">=</span><span class="n">precision</span><span class="p">)</span>

        <span class="c1"># diagonal cov now</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eig_vecs</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cov</span><span class="p">),</span> <span class="n">eig_vecs</span><span class="p">)</span>

    <span class="c1"># just requesting covariance</span>
    <span class="k">if</span> <span class="kc">True</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">return_info_mat</span><span class="p">,</span> <span class="n">return_derivs</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">cov</span>

    <span class="c1"># if desiring more information, create a list capable of variable size</span>
    <span class="n">returns</span> <span class="o">=</span> <span class="p">[</span><span class="n">cov</span><span class="p">]</span>

    <span class="c1"># add information matrix</span>
    <span class="k">if</span> <span class="n">return_info_mat</span><span class="p">:</span>
        <span class="n">returns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info_mat</span><span class="p">)</span>

    <span class="c1"># add derivatives</span>
    <span class="k">if</span> <span class="n">return_derivs</span><span class="p">:</span>
        <span class="n">returns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">returns</span></div>



<div class="viewcode-block" id="plot_covariance_corner">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.plot_covariance_corner">[docs]</a>
<span class="k">def</span> <span class="nf">plot_covariance_corner</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">cov</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">nsamp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25000</span><span class="p">,</span>
    <span class="n">fig</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">Figure</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Figure</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a corner plot for a given covariance matrix.</span>

<span class="sd">    The `corner &lt;https://corner.readthedocs.io/en/latest/&gt;`_ module is required for this.</span>

<span class="sd">    Args:</span>
<span class="sd">        params: The set of parameters used for the event (the mean vector of the covariance matrix).</span>
<span class="sd">        cov: Covariance matrix from which to construct the corner plot.</span>
<span class="sd">        nsamp: Number of samples to draw from the multivariate distribution.</span>
<span class="sd">        fig: Matplotlib :class:`plt.Figure` object. Use this if passing an existing corner plot figure.</span>
<span class="sd">        **kwargs: Keyword arguments for the corner plot - see the module documentation for more info.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The corner plot figure.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: add capability for ChainConsumer?</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">corner</span>
    <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Attempting to plot using the corner module, but it is not installed.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># generate fake samples from the covariance distribution</span>
    <span class="n">samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nsamp</span><span class="p">)</span>

    <span class="c1"># make corner plot</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">corner</span><span class="o">.</span><span class="n">corner</span><span class="p">(</span><span class="n">samp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fig</span></div>



<div class="viewcode-block" id="plot_covariance_contour">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.plot_covariance_contour">[docs]</a>
<span class="k">def</span> <span class="nf">plot_covariance_contour</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">cov</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">horizontal_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">vertical_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nsamp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">25000</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span> <span class="o">|</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">plt</span><span class="o">.</span><span class="n">Figure</span><span class="p">,</span> <span class="n">plt</span><span class="o">.</span><span class="n">Axes</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct a contour plot for a given covariance matrix on a single axis object.</span>

<span class="sd">    The `corner &lt;https://corner.readthedocs.io/en/latest/&gt;`_ module is required for this.</span>

<span class="sd">    Args:</span>
<span class="sd">        params: The set of parameters used for the event (the mean vector of the covariance matrix).</span>
<span class="sd">        cov: Covariance matrix from which to construct the corner plot.</span>
<span class="sd">        horizontal_index: Parameter index to plot along the horizontal axis of the contour plot.</span>
<span class="sd">        vertical_index: Parameter index to plot along the vertical axis of the contour plot.</span>
<span class="sd">        nsamp: Number of samples to draw from the multivariate distribution.</span>
<span class="sd">        fig: Matplotlib :class:`plt.Figure` object. Use this if passing an existing corner plot figure.</span>
<span class="sd">        **kwargs: Keyword arguments for the corner plot - see the module documentation for more info.</span>

<span class="sd">    Returns:</span>
<span class="sd">        If ``ax`` is provided, the return will be that ax object. If it is not provided, then a</span>
<span class="sd">        Matplotlib Figure and Axes obejct is created and returned as a tuple: ``(plt.Figure, plt.Axes)``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: add capability for ChainConsumer?</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">corner</span>
    <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
            <span class="s2">&quot;Attempting to plot using the corner module, but it is not installed.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># generate fake samples from the covariance distribution</span>
    <span class="n">samp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">cov</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nsamp</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">samp</span><span class="p">[:,</span> <span class="n">horizontal_index</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">samp</span><span class="p">[:,</span> <span class="n">vertical_index</span><span class="p">]</span>

    <span class="c1"># make corner plot</span>
    <span class="n">corner</span><span class="o">.</span><span class="n">hist2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ax</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span></div>



<div class="viewcode-block" id="get_eigeninfo">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.get_eigeninfo">[docs]</a>
<span class="k">def</span> <span class="nf">get_eigeninfo</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">high_precision</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs eigenvalue decomposition and returns the eigenvalues and right-eigenvectors for the supplied fisher/covariance matrix.</span>

<span class="sd">    Args:</span>
<span class="sd">        arr: Input matrix for which to perform eigenvalue decomposition.</span>
<span class="sd">        high_precision: If ``True``, use 500-dps precision to ensure accurate eigenvalue decomposition</span>
<span class="sd">            (requires `mpmath &lt;https://mpmath.org&gt;`_ to be installed). Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple containing Eigenvalues and right-Eigenvectors for the supplied array, constructed such that evects[:,k] corresponds to evals[k].</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">high_precision</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">mpmath</span> <span class="k">as</span> <span class="nn">mp</span>

            <span class="n">mp</span><span class="o">.</span><span class="n">mp</span><span class="o">.</span><span class="n">dps</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mpmath is not installed - using low-precision eigen decomposition.&quot;</span><span class="p">)</span>
            <span class="n">high_precision</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">high_precision</span><span class="p">:</span>
        <span class="n">hp_arr</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="c1"># get eigenvectors</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">EL</span><span class="p">,</span> <span class="n">ER</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">hp_arr</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># convert back</span>
        <span class="n">evals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">evects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ER</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evects</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">evals</span><span class="p">,</span> <span class="n">evects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">evals</span><span class="p">,</span> <span class="n">evects</span></div>



<div class="viewcode-block" id="cutler_vallisneri_bias">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.cutler_vallisneri_bias">[docs]</a>
<span class="k">def</span> <span class="nf">cutler_vallisneri_bias</span><span class="p">(</span>
    <span class="n">waveform_model_true</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span>
    <span class="n">waveform_model_approx</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">input_diagnostics</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">info_mat</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">deriv_inds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_derivs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">return_cov</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">parameter_transforms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TransformContainer</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">waveform_true_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">waveform_true_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">waveform_approx_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">waveform_approx_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">inner_product_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the Cutler-Vallisneri bias.</span>

<span class="sd">    # TODO: add basic math</span>

<span class="sd">    Args:</span>
<span class="sd">        waveform_model_true: Callable function to the **true** waveform generator with signature ``(*params, **waveform_kwargs)``.</span>
<span class="sd">        waveform_model_approx: Callable function to the **approximate** waveform generator with signature ``(*params, **waveform_kwargs)``.</span>
<span class="sd">        params: Source parameters.</span>
<span class="sd">        eps: Absolute **derivative** step size. See :func:`info_matrix`.</span>
<span class="sd">        input_diagnostics: Dictionary including the diagnostic information if it is precomputed. Dictionary must include</span>
<span class="sd">            keys ``&quot;cov&quot;`` (covariance matrix, output of :func:`covariance`), ``&quot;h_true&quot;`` (the **true** waveform),</span>
<span class="sd">            and ``&quot;dh&quot;`` (derivatives of the waveforms, list of outputs from :func:`dh_dlambda`).</span>
<span class="sd">        info_mat: Pre-computed information matrix. If supplied, this matrix will be inverted to find the covariance.</span>
<span class="sd">        deriv_inds: Subset of parameters of interest. See :func:`info_matrix`.</span>
<span class="sd">        return_derivs: If ``True``, also returns computed numerical derivatives.</span>
<span class="sd">        return_cov: If ``True``, also returns computed covariance matrix.</span>
<span class="sd">        parameter_transforms: `TransformContainer &lt;https://mikekatz04.github.io/Eryn/html/user/utils.html#eryn.utils.TransformContainer&gt;`_ object. See :func:`info_matrix`.</span>
<span class="sd">        waveform_true_args: Arguments for the **true** waveform generator.</span>
<span class="sd">        waveform_true_kwargs: Keyword arguments for the **true** waveform generator.</span>
<span class="sd">        waveform_approx_args: Arguments for the **approximate** waveform generator.</span>
<span class="sd">        waveform_approx_kwargs: Keyword arguments for the **approximate** waveform generator.</span>
<span class="sd">        inner_product_kwargs: Keyword arguments for the inner product function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        List of return information. By default, it is ``[systematic error, bias]``.</span>
<span class="sd">        If ``return_derivs`` or ``return_cov`` are ``True``, they will be added to the list with derivs added before covs.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">deriv_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">deriv_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">info_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">input_diagnostics</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Provided info_mat and input_diagnostics kwargs. Ignoring info_mat.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># adjust parameters to waveform basis</span>
    <span class="n">params_in</span> <span class="o">=</span> <span class="n">parameter_transforms</span><span class="o">.</span><span class="n">transform_base_parameters</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">input_diagnostics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># get true waveform</span>
        <span class="n">h_true</span> <span class="o">=</span> <span class="n">waveform_model_true</span><span class="p">(</span>
            <span class="o">*</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">params_in</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">waveform_true_args</span><span class="p">)),</span> <span class="o">**</span><span class="n">waveform_true_kwargs</span>
        <span class="p">)</span>

        <span class="c1"># get covariance info and waveform derivatives</span>
        <span class="n">cov</span><span class="p">,</span> <span class="n">dh</span> <span class="o">=</span> <span class="n">covariance</span><span class="p">(</span>
            <span class="n">eps</span><span class="p">,</span>
            <span class="n">waveform_model_true</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">return_derivs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">deriv_inds</span><span class="o">=</span><span class="n">deriv_inds</span><span class="p">,</span>
            <span class="n">info_mat</span><span class="o">=</span><span class="n">info_mat</span><span class="p">,</span>
            <span class="n">parameter_transforms</span><span class="o">=</span><span class="n">parameter_transforms</span><span class="p">,</span>
            <span class="n">waveform_args</span><span class="o">=</span><span class="n">waveform_true_args</span><span class="p">,</span>
            <span class="n">waveform_kwargs</span><span class="o">=</span><span class="n">waveform_true_kwargs</span><span class="p">,</span>
            <span class="n">inner_product_kwargs</span><span class="o">=</span><span class="n">inner_product_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># pre-computed info</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="n">input_diagnostics</span><span class="p">[</span><span class="s2">&quot;cov&quot;</span><span class="p">]</span>
        <span class="n">h_true</span> <span class="o">=</span> <span class="n">input_diagnostics</span><span class="p">[</span><span class="s2">&quot;h_true&quot;</span><span class="p">]</span>
        <span class="n">dh</span> <span class="o">=</span> <span class="n">input_diagnostics</span><span class="p">[</span><span class="s2">&quot;dh&quot;</span><span class="p">]</span>

    <span class="c1"># get approximate waveform</span>
    <span class="n">h_approx</span> <span class="o">=</span> <span class="n">waveform_model_approx</span><span class="p">(</span>
        <span class="o">*</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">params_in</span><span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">waveform_approx_args</span><span class="p">)),</span> <span class="o">**</span><span class="n">waveform_approx_kwargs</span>
    <span class="p">)</span>

    <span class="c1"># adjust/check waveform outputs</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h_true</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">h_true</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">h_true</span> <span class="o">=</span> <span class="p">[</span><span class="n">h_true</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h_true</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">h_true</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">h_true</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">h_true</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h_approx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">h_approx</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">h_approx</span> <span class="o">=</span> <span class="p">[</span><span class="n">h_approx</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">h_approx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">h_approx</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">h_approx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">h_approx</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_approx</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_true</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">h_approx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_true</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h_true</span><span class="p">))])</span>
    <span class="p">)</span>

    <span class="c1"># difference in the waveforms</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">h_true</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">h_approx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">h_approx</span><span class="p">))]</span>

    <span class="c1"># systematic err</span>
    <span class="n">syst_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">inner_product</span><span class="p">(</span>
                <span class="n">dh</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
                <span class="n">diff</span><span class="p">,</span>
                <span class="o">**</span><span class="n">inner_product_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">deriv_inds</span><span class="p">))</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="n">bias</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">syst_vec</span><span class="p">)</span>

    <span class="c1"># return list</span>
    <span class="n">returns</span> <span class="o">=</span> <span class="p">[</span><span class="n">syst_vec</span><span class="p">,</span> <span class="n">bias</span><span class="p">]</span>

    <span class="c1"># add anything requested</span>
    <span class="k">if</span> <span class="n">return_cov</span><span class="p">:</span>
        <span class="n">returns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_derivs</span><span class="p">:</span>
        <span class="n">returns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dh</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">returns</span></div>



<div class="viewcode-block" id="scale_to_snr">
<a class="viewcode-back" href="../../user/diagnostic.html#lisatools.diagnostic.scale_to_snr">[docs]</a>
<span class="k">def</span> <span class="nf">scale_to_snr</span><span class="p">(</span>
    <span class="n">target_snr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">sig</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span>
    <span class="o">*</span><span class="n">snr_args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
    <span class="n">return_orig_snr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">snr_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the SNR and scale a signal.</span>

<span class="sd">    Args:</span>
<span class="sd">        target_snr: Desired SNR value for the injected signal.</span>
<span class="sd">        sig: Signal to adjust. A copy will be made.</span>
<span class="sd">            Can be time-domain or frequency-domain.</span>
<span class="sd">            Must be 1D ``np.ndarray``, list of 1D ``np.ndarray``s, or 2D ``np.ndarray``</span>
<span class="sd">            across channels with shape ``(nchannels, data length)``.</span>
<span class="sd">        *snr_args: Arguments to pass to :func:`snr`.</span>
<span class="sd">        return_orig_snr: If ``True``, return the original SNR in addition to the adjusted data.</span>
<span class="sd">        **snr_kwargs: Keyword arguments to pass to :func:`snr`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Returns the copied input signal adjusted to the target SNR. If ``return_orig_snr is True``, the original</span>
<span class="sd">        SNR is added as the second entry of a tuple with the adjusted signal (as the first entry in the tuple).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get the snr and adjustment factor</span>
    <span class="n">snr_out</span> <span class="o">=</span> <span class="n">snr</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="o">*</span><span class="n">snr_args</span><span class="p">,</span> <span class="o">**</span><span class="n">snr_kwargs</span><span class="p">)</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">target_snr</span> <span class="o">/</span> <span class="n">snr_out</span>

    <span class="c1"># any changes back to the original signal type</span>
    <span class="n">back_single</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">back_2d_array</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">sig</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="p">[</span><span class="n">sig</span><span class="p">]</span>
        <span class="n">back_single</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">sig</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
        <span class="n">back_2d_array</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># adjust</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">sig_i</span> <span class="o">*</span> <span class="n">factor</span> <span class="k">for</span> <span class="n">sig_i</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">]</span>

    <span class="c1"># adjust type back to the input type</span>
    <span class="k">if</span> <span class="n">back_2d_array</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">back_single</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">return_orig_snr</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">snr_out</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Michael L. Katz 2024.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>